// MIT License

// Copyright (c) 2021 Mike Gowanlock

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#include "structsDBSCAN.h"
#include <vector>
#include "RTree.h"
#include "params.h"

using namespace std;

//DBScan:
//Input: the points, the threshold distance, and the minimum number of points to form a cluster, and the pointer to the R-tree index
class DBScan{

	////////////////////////////////////
	///Public
	////////////////////////////////////	
	public:
	//Constructor input: 
	//pointer to the data elements (*ptrData)
	//the distance: epsilon
	//the minimum number of points to form a cluster: minimumPts
	//a pointer to the R-tree index: *indexPtr
	//a pointer to the cache that may contain precomputed neighbors
	
	

	//for the pure sequential implementation with 1 MBB per point object
	DBScan(std::vector<struct dataElem> *ptrData, DTYPE epsilon, int minimumPts, 
		RTree<int,DTYPE,2,float> *indexPtr);


	

	//the DBScan algorithm	that gets called
	void algDBScan();	

	//Original algorithm before switching to sets not vectors for neighborhoods
	void algDBScanWithSet();

	

	
	
	//method that takes as input a finished cluster and then tries to isolate clusters that won't change
	void getIsolatedClusters(int finishedInstanceID);

	//method that generates an MBB around a cluster
	void generateMBBAroundCluster(std::vector<int>*clusterPoints, DTYPE * MBB_min, DTYPE * MBB_max);

	//method that appends an MBB
	void appendMBBByEpsilon(DTYPE * MBB_min, DTYPE * MBB_max, DTYPE eps);

	//stump of DBScan used when assigning points to predefined clusters
	//just the part of the algoroithm that expands the eps-neighbourhood
	void DBScanParallelMPBSTUMP(int finishedInstanceID, bool * destroyedArr, std::vector<int>* candidatesToGrowFrom);

	//method that builds new clusters from old clusters:
	void assignPointsToPredefinedCluster(int finishedInstanceID);


	//sets the order in which we visit and reuse the various clusters based on heuristics
	
	//uses the previous ordering from the previous clusters results:
	void setClusterScheduleNONE(std::vector<int>* schedule, std::vector<int> clusterArr[], int numClustersInOtherInstance);

	//based on density
	void setClusterScheduleDensity(std::vector<int>* schedule, std::vector<int> clusterArr[], int numClustersInOtherInstance);
	
	//based on the density*points (weights the number of points higher) because its (points*points)/area
	void setClusterSchedulePointsSquared(std::vector<int>* schedule, std::vector<int> clusterArr[], int numClustersInOtherInstance);




	//reuse clusters but from the perspective of the points, not the clusters. Similar instruction flow to the original DBScan alg
	//void algDBScanParallelSimilarInstructionFlow(int finishedInstanceID);


	//function to output the clusters and the data points within them
	//cluster 0 contains the noise points.
	void outputClusters(char * fname);

	//function to compare the result of two cluster runs and see how equal the point assignments are
	//this is to compare implementations with multiple segments per MBB to the sequential version.
	void calcErrorPointsInCluster(std::vector<int> * inputClusterArray);


	//a pointer to an array of DBScan objects:
	void setInstances(DBScan * instances, int numInstances);


	//for calculating the error in 2 clusters
	void DetermineErrorTwoClusterResults(std::vector<int> * c1, std::vector<int> * c2);

	void DetermineErrorTwoClusterResultsBACKUP(std::vector<int> * c1, std::vector<int> * c2);

	//method to allow this instance to "fill in" the cache for other instances that haven't finished
	void supplementCache();

	//older one that always fills in the cache using the tree
	void supplementCacheOLD();


	//gets the number of clusters generated by a DBScan instance:
	int getDBScanNumClusters();



	//vector that keeps track of the assignment of the points to a cluster
	//cluster 0 means a noise point
	//the indices of the vector correspond to the data points
	//so element i in clusterIDs corresponds to the cluster that data element i is in within the dataPoints struct
	//made public so it can be used by calcErrorPointsInCluster 
	//which checks the error in the two sets of points assigned to their respective clusters
	std::vector<int>clusterIDs;


	//vector that keeps cached points for a new implementation
	//that caches its neighbours
	std::vector<int> * localCache;
	int instanceID;


	//vector of pointers to the DBScan instances that may have cached points
	std::vector<DBScan *> instanceVect;

	//some statistics:
	//the time it takes to compute which clusters should be grown
	double timeToCalculateClusterSchedule;	
	//the number of points reused
	int numPointsReused;
	//the number of clusters created for stats
	int numClustersForStats;


	////////////////////////////////////
	///Private
	////////////////////////////////////
	private:
	
	DTYPE distance;
	int minPts;
	int clusterCnt; //the number of clusters found after calling the algorithm





	//vector that keeps track of the points that have beeen visited
	std::vector<bool>visited;


	//both used for testing omp implementation for the distance calculations
	std::vector<int>listOfDeconstuctedPointIDs;
	

	//pointer to the data elements
	std::vector<struct dataElem> *dataPoints;

	//pointer to the lookup array for multiple pointers per MBB (MPB)
	std::vector<std::vector<int> > *ptrMPBlookup;

	
	//temporary vector used to store the ids of the candidates that are actually within the 
	//threshold distance.
	std::vector<int> setIDsInDist;	

	//temporary vector used to store the ids of the candidates that are actually within the 
	//threshold distance.
	//for the parallel version where the neighbours are precomputed
	std::vector<int> * setIDsInDistParallel;



	//pointer to the R-tree index
	RTree<int,DTYPE,2,float> *tree; 

	//pointer to the R-tree index that has 1 point per box to discern if results can be reused across clustering runs
	RTree<int,DTYPE,2,float> *treeHighResolution; 

	


	
	

	

	
	
	//R-tree version of the algorithm, thus making the algorithm O(nlogn), where 
	//n is the number of points
	//void getNeighbours(struct dataElem * point, DTYPE distance);
	void getNeighbours(struct dataElem * point, DTYPE distance, std::vector<int> * setIDsInDistPtr);



	//R-tree version of the algorithm, thus making the algorithm O(nlogn), where 
	//n is the number of points
	//FOR THE PARALLEL SEARCH
	void getNeighboursParallel(struct dataElem * point, DTYPE distance, std::vector<int> * setIDsInDistPtr);





	//Used for thread synchronization for the threads in the parallel implementation
	void updateThreadStatuses(bool * threadStatus);

	//Used for thread synchronization for the threads in the parallel implementation
	bool globalThreadStatus(bool * threadStatus);

	//brute force version of getting the neighbors, thus making the time complexity O(n^2), where 
	//n is the number of points. Use this to compare with the R-tree version
	void getNeighboursBruteForce(struct dataElem * point, DTYPE distance);

	//initialize all of the points to initially not be visited
	void initializeVisitedPoints(int size);

	//generate a query MBB around the point to search for the values
	//this supports the other two generate MBB methods 
	void generateMBB(struct dataElem * point, DTYPE distance, DTYPE * MBB_min, DTYPE * MBB_max);

	//generate a query MBB around the point to search for the values
	//returns true if it was able to generate the query using a single MBB
	//returns false if it needs two MBBs because the query wraps around the longitude of 360 degrees
	bool generateMBBNormal(struct dataElem * point, DTYPE distance, DTYPE * MBB_min, DTYPE * MBB_max);

	//called when the query MBB wraps around the longitude of 360 degrees 
	//we then need two MBBs to define the query region.
	void generateTwoMBBs(struct dataElem * point, DTYPE distance, DTYPE * MBB_min1, DTYPE * MBB_max1, DTYPE * MBB_min2, DTYPE * MBB_max2);




	//called to filter the candidate set of points returned from the index (see below for a special case)
	int filterCandidates(struct dataElem * point, std::vector<int> * candidateSet, DTYPE distance, std::vector<int> * setIDsInDistPtr);

	



    int filterCandidatesSpecialCaseMPB(struct dataElem * point, std::vector<int> * candidateSet, DTYPE distance, std::vector<int> * setIDsInDistPtr);
    
    int filterCandidatesMPB_BACKUP(struct dataElem * point, std::vector<int> * candidateSet, DTYPE distance, std::vector<int> * setIDsInDistPtr);

    int filterCandidatesMPB(struct dataElem * point, std::vector<int> * candidateSet, DTYPE distance, std::vector<int> * setIDsInDistPtr);

    void getNeighboursParallelMPB(struct dataElem * point, DTYPE distance, std::vector<int> * setIDsInDistPtr);

    //function used in algDBScanParallelPrecomputeDirectNeighboursMPB to in parallel compute the
    //list of direct neighbours 
    void PrecomputeDirectNeighboursMPB(std::vector<int> *individualDirectNeighbours);

	//the function that calculates the distance between two points. Used when filtering the 
	//candidate set
	double EuclidianDistance(struct dataElem * point1, struct dataElem * point2);


	//the spherical distance function
	double SphericalDistance(struct dataElem * point1, struct dataElem * point2);

	//copies the contents from the source vector and appends them to the dest vector
	void copyVect(std::vector<int> * dest, std::vector<int> * source);

	//copies the contents from the source vector and adds them to the concurrent queue
	//for the parallel version
	//void addToQueue(tbb::concurrent_queue<int> * dest, std::vector<int> * source);

	//initializes the vector storing the IDs of the cluster of the data points
	void initializeClusterIDs(int size);

	//function to print a set
	void printSet(std::vector<int> * set);


};






